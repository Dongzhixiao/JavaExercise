package org.dongzhixiao.day10.thread;
/**
 * 多线程
 * 进程：一个操作系统中同时运行多个任务(程序)。系统级别上的多线程，每个任务叫做进程
 * 线程：一个程序可能运行多个任务。那么每个任务就叫一个线程
 * 并非：线程是并发运行的。操作系统将时间划分为若干个片段(时间片),尽可能的均匀分配
 * 给每一个任务，被分配时间片后，任务就有机会被cpu所执行。随着cpu高效的运行，宏观
 * 上看所有的任务都在运行。但微观上看，每个任务都是走走停停。这种现象称之为并发。
 *
 * 线程调度：
 *  该机制会将所有并发任务做同一的调度工作，划分时间片(可以被cpu执行的时间)给
 *  每一个任务，时间片竟可能均匀，但做不到绝对均匀。同样，被分配时间片后，该任务
 *  被cup执行，但调度的过程中不能保证所有任务都是平均的获取时间片的次数。只能
 *  做到尽可能平均。这两个都是程序不可控的。
 **********************************************
 * 另一种创建线程的方式
 * 将线程逻辑与执行逻辑分离开。
 * 因为有了这样的设计，才有了【线程池】。
 * 关注点在于执行的逻辑
 * Runnable接口：用于定义线程要执行的任务逻辑。
 * 我们定义一个类实现Runnable接口，这时我们必须重写run方法。
 * 在其中定义我们要执行的逻辑，之后将Runnable交给线程去执行。
 * 从而实现了线程与其执行的任务分离开。
 *     【解耦：线程与线程体解耦。】  ----  解耦就是打断依赖关系。
 * Spring的ioc就是干这个的。
 * 
 * @author Administrator
 *
 * Thread类――――线程类
 * Thread类的实例代表――――一个并发任务
 * 并发的任务逻辑是通过重写Thread的run方法实现的。
 */
public class TestThread {

    public static void main(String[] args) {
        /**
         * 测试并发操作多个任务
         */
        Thread t1 = new MyFirstThread();
        Thread t2 = new MySecThread();
        
        t1.start();
        t2.start();
        
      //不要使用这个方法！不安全，应通过run方法的执行完毕自然结束
//        t1.stop();
    }

}
